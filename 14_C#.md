# C#

## Resources:
- **Theorical:**
    - ‚úîÔ∏è Principles of OOP: https://journey.study/v2/learn/materials/oop-principles-1q2023
    - ‚úîÔ∏è What is .NET? https://journey.study/v2/learn/materials/pages/tools/about-dotnet.md
    - ‚úîÔ∏è C# vs JS: https://www.educba.com/c-sharp-vs-js/
    - ‚úîÔ∏è Overview of Classes, Structs abd Records: https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/
    - ‚ùå Compiled vs Interpreted lanugages: https://www.geeksforgeeks.org/difference-between-compiled-and-interpreted-language/
    - ‚ùå Type system in C#: https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/
    - ‚ùå Full list of C# types: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/built-in-types
    - ‚ùå Numbers:
        - Integral types: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types
        - Floating-point types: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types
    - ‚ùå Strings: https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/strings/
    - ‚ùå Arrays: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/arrays
    - ‚ùå Collections: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/collections
    - ‚ùå Nullable references: https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references
    
    - ‚ùå Properties: https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties
    - ‚ùå Constructors: https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors
- **Tutorials:**
    - ‚úîÔ∏è Setting up a project in Rider: https://journey.study/v2/learn/materials/pages/tools/csharp-helloworld-rider                      
    - ‚ùå .NET tutorials: https://dotnet.microsoft.com/en-us/learn
    - ‚úîÔ∏è Step-by step tutorial inside browser: https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/tutorials/hello-world?tutorial-step=1
    - ‚úîÔ∏è Microsoft basic tutorial: https://learn.microsoft.com/en-gb/shows/csharp-101/?wt.mc_id=educationalcsharp-c9-scottha
    - ‚úîÔ∏è Collection of tutorials: https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/tutorials/
    - ‚ùå Another basic C# free tutorial on codeacademy: https://www.codecademy.com/learn/learn-c-sharp
    - ‚úîÔ∏è Classes and Objects bank account tuts:    https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/classes
                                                https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/oop
- ‚è≥ (LINQ part still not watched!) Full Microsoft video course: https://www.youtube.com/playlist?list=PLdo4fOcmZ0oVxKLQCHpiUWun7vlJJvUiN

- **Further reads (non-mandatory):**
    - üí≠ Memory management: https://endjin.com/blog/2022/07/understanding-the-stack-and-heap-in-csharp-dotnet

## FUNDAMENTALS AND BASIC CONCEPTS:
- Introduction to C#:
    - In any kind of programming, there are 2 basic elements: DATA and OPERATIONS that are performed on the data (Youtube - Videos; Facebook - User data)
    - The programmer's role:
        - have an **algorithmic mind** to be able to define the steps that lead from the initial state of raw data to the desired outcome
        - they need to be able to define the data as information:
            - **abstraction:** coming up with a way to represent some concrete or abstract idea in a way that a computer could work with it (real world "things" represented as objects with properties)

- Static vs Dynamic typing:
    - **Dynamic:** You create data and the tpye is defined later, based on it's content (Javascript, Python)
    - **Static:** You need to define the type of the data when you create it (C, C++, C#, Java)

- C# is an object-oriented programming language. The four basic principles of object-oriented programming contribute to writing more testable, flexible, and maintainable code, and they are:
    - **Abstraction**   Modeling the relevant attributes and interactions of entities as classes to define an abstract representation of a system.
                        (Representing the problem domain with a simplified model)
    - **Encapsulation** Hiding the internal state and functionality of an object and only allowing access through a public set of functions.
                        (Hiding the inner workings of a component by only allowing access to it through a public set of functions)
    - **Inheritance**   Ability to create new abstractions based on existing abstractions.
    - **Polymorphism**  Ability to implement inherited properties or methods in different ways across multiple abstractions.

- What is **.NET** ?
    - a framework (=a set of tools and libraries) developed & maintained by Microsoft
    - Besides the libraries that support these use cases, the platform also includes:
        - **.NET compilers (Roslyn)**
        - **Base Class Library (BCL)**
        - **Common Language Runtime (CLR)**
            - a virtual machine that handles the execution of applications
            - provides services like thread management, garbage collection, type-safety, exception handling
            - *common* refers to the support of multiple languages (C#, Visual Basic, F# -> these all run on the CLR)
                - an **IL** (Intermediate Language) is created from the code, which is a compressed format
                - Then the CLR translates it into machine code during execution, using **JIT** (Just-in-Time compilation)
    - The main **strength of .NET** versus other ecosystems comes from the fact that languages and the framework are **being developed by the same entity**
    - **.NET** vs **.NET Framework**:
        - **.NET** is multi-platform, while **.NET Framework** is the original Windows only version

- **C#** vs **JavaScript**:
    - Summary: 
        - C# is a strictly typed object-oriented programming language, and it‚Äôs used to develop console applications
        - Desktop applications and C# cannot run without the .NET framework
        - JavaScript is a client-side scripting language used primarily for making interactive effects in web applications. It can execute in any web browser.
    
    - The main **advantages of C#**:
        - Language-Integrated Query (LINQ) expressions make the strongly-typed query a first-class language construct.
        - Supports encapsulation, inheritance, and polymorphism because it‚Äôs an object-oriented language.
        - Supports inline XML documentation comments.
        - It is statically typed.
        - It has an operator and conversion overloading.
    
    - Journey article comparison:
        - JavaScript is a prototype-based language, but c# is not.
        - Javascript is a scripting language for web browsers. It also is known as New PHP, but C# doesn‚Äôt provide any feature like this.
        - JavaScript is dynamically and weakly typed, but C# is statically and strongly.
        - JavaScript‚Äôs primary programming paradigm is procedural, but C# primary programming paradigm is (class-based) object-oriented.
        - Javascript doesn‚Äôt have an Integer datatype, but C# has an integer data type. (?)
        - Javascript doesn‚Äôt have array datatype, but C# supports array data type. (?)
        - In JavaScript, we use ‚Äúfunction [function name],‚Äù and in C#, we use ‚Äúvoid [function name]‚Äù or other function types.
        - C# runs the .NET framework, and it is best for making Desktop Applications while Javascript runs in a browser, so for making games and quiz other applications, JavaScript is better.
        - C# is a compiled programming language. JavaScript is a scripting language. So, JavaScript can fail due to syntactic errors at runtime.
    
    ![Alt text](assets/C-vs-JavaScript-info.jpg.webp)

    - ChatGPT comparison:
        - Typing System:
            JavaScript is **dynamically** typed, meaning variable types are determined at runtime and can change.
            C# is **statically** typed, with explicit type declarations and type checking at compile time.
        - Execution Environment:
            JavaScript is **primarily used for web development, running on browsers**, but also on servers (Node.js).
            C# is a **general-purpose language mainly used in .NET framework**, often for desktop applications, server-side applications, and more recently, web development with Blazor.
        - Syntax and Language Features:
            JavaScript syntax is influenced by C, but it includes more **functional programming features**.
            C# syntax is similar to Java and C++, and it **supports both object-oriented** and increasingly more **functional programming** styles.
        - Memory Management:
            JavaScript uses **automatic memory management** (garbage collection) with limited direct control.
            C# also uses garbage collection but **offers more options for memory management** and optimization.
        - Concurrency Model:
            JavaScript **historically used a single-threaded, event-driven model**, but now supports concurrency with Web Workers and **async/await**.
            C# **supports multi-threading** and various advanced concurrency and parallelism models.
        - Community and Ecosystem:
            JavaScript has a vast **ecosystem mainly around web technologies and Node.js**.
            C# is **strongly associated with Microsoft and the .NET ecosystem**, with a focus on enterprise applications, gaming (Unity), and more recently, cross-platform development.
    
- **C# file system:**
    - NEW vs OLD template: https://learn.microsoft.com/en-gb/dotnet/core/tutorials/top-level-templates
        - New: 
            - As if we were writing everything inside the `Main` function 
            - All functions created here are local functions, so we can't add access modifiers to them(eg `private` or `public`), they will be `static` 
    - `using System;`:
        - imports System library, that we need to use the Console (same as writing System.Console.Writeline("") every time )
        - `using` is called the **Using directive**, that allows the import of **TYPES** (Classes, interfaces, structs) from a namespace
        - Whenever you want to use a class that is defined in another namespace than the current class, you need to import that namespace, or use the fully qualified name of the class.
    - `namespace ConsoleApp6` 
        - they are **collections of TYPEs**
        - groups and organizes code (in case of multiple classes, it's good to keep the ones together that belong together)
        - the default namespace of a project in Rider is the project's name (eg. "HelloWorld") and this is also the best practice
    - `class Program` 
        - classes are blueprints or schematics from which objects will be create at runtime
        - this is the class we are working in
        - class modifier (eg. `internal`) means where we can use this class. `public` would mean we can use it outside the project as well.
    - `static void Main(string[] args)` 
        - this is the method we are wokring in, the entry point of the application (void refers to the return value - void doesn't return anything)
        - The compiler looks for the method called exactly `Main` to run, so if we rename it, it won't run
        - Access modifier: `public` 
            - it's best practice to keep it `public`
            - this could also be `protected` or `private`
        - `static` means the method belongs to the class itself (and won't be created in objects created from the class) - invoke it/ call it by specifying the class name as well: `Program.Main();`
        - `void` is the return type, which means the method doesn't return anything.
        - `string[] args`:
            - an input parameter of a string array called args
            - used to pass parameters into the application from the command line

- **Build process and execution:**
    - **Build process:**
        - When clicking "Run", the **building** process is initialized:
            1.  The .NET **compiler** (called Roslyn) **performs static analysis to validate the syntax** and semantics of the code.<br>
                If any errors are found, the build process is halted.
            2.  The compiler **generates a compressed version** of the source code. The target language is called the **IL** or **CIL** (*Common Intermediate Language*).<br>
                This is a CPU- and platform-independent instruction set that can be executed in any environment that supports it.
            3.  The generated CIL code is written into `.dll` files called **assemblies**.<br>
                The generated assemblies (and any other third-party assemblies our code requires) are placed in the project's output directory, along with an executable (.exe) if our project is runnable (e.g. a console app.).<br>
                For Class Library type projects, no executables are generated.
                (Output directory path: *{SolutionName}{ProjectName}\bin\Debug\net8.0* // *HelloWorld\HelloWorld\bin\Debug\net8.0* )
    - **Program execution:**
        - If the build was successful, the app will be run
        - The execution is performed by a platform called `runtime`, which in .NET is called the **CLR** (*Common Language Runtime*)
            - "common" means it's used for all .NET languages (C#, Visual Basic, F#, Visual C++), as they all compile to the same CIL.
        - **C#** is a **managed language**, which means the memory management is done automatically by the runtime.
            - The CLR takes of the memory allocation when a new object is created
            - CLR has a component called **Garbage Collector**, that constatly looks for unused objects, that could free up space.
            - CLR also proveides services like *boundaries*, *reflection* and *type safety*
        - The CLR takes the generated CIL or IL code from the assemblies, and translates it into machine code (1s and 0s), and this code will be run in the end.

- **Memory management in C#:**
    - There are 2 types of memory in C# to store data:
        - **The stack:**
            - Its main purpose is to control the execution flow of the program by tracking the method calls
            - Local variables, specific to the executing method are also stored here.
            - These are short-lived variables that go out of scope once the method which declared them finished the execution.
            - Any `value types` by default will be allocated on the stack.
        - **The heap:**
            - Used to store data that needs to survive through the specific method calls.
            - This area of the memory is managed by the **Garbage Collector**.
            - By default, any `reference types` you create gets allocated on the heap.
    - **Equality overriding:**
        - By default, equality is checked by reference (so it checks if a variable and another variable point to the same reference in the memory), so:

                // When we create "card2", we only copy the reference:
                Card card1 = new Card("Ace", Suit.Spades);
                Card card2 = card1;

                Console.WriteLine(card1 == card2); // Prints True

                // The objects are identical, but point to a different place in the memory:
                Card card1 = new Card("Ace", Suit.Spades);
                Card card2 = new Card("Ace", Suit.Spades);

                Console.WriteLine(card1 == card2); // Prints False
        
        - If we want the equality to be *based on the attributes we define* (not on the references), we need to implement our own equality method.
            - This is a design choice that we need to think about when creating the model class:
                - Overwrite `Equals` & `GetHashCode` methods inherited from `Object` *base class* (see tutorial at the end)
                - After override, we should compare not with `==`, but with `obj1.Equals(obj2)` method

- **TYPES - Classes, Structs and Records:**
    - the definition of a **type** is like a blueprint that specifies what the **type** can do (a **class**, **struct**, or **record**)
    - A class or struct can specify how accessible each of its members is to code outside of the class or struct:
        - Methods and variables that aren't intended to be used from outside of the class or assembly can be hidden
    - **Type MEMBERS:**
        - The members of a type include all methods, fields, constants, properties, and events
        - In C#, there are no global variables or methods as there are in some other languages:
            - Even a program's entry point, the Main method, must be declared within a class or struct
        - Members that may be declared in a class, struct, or record:
            - Fields
            - Constants
            - Properties (eg *Bank Account Number* or *Owner*)
            - Methods (eg *MakeDeposit()* )
            - Constructors (has the same name as the class and assigns the initial values to a new object created from eg. the *BankAccount* type, using `new` keyword)
                - `this`: The `this` qualifier is only required when a local variable or parameter has the same name as that field or property:
                        
                        // Inside the constructor, where name is an initial parameter:
                        this.Owner = name;
                        
                        // same as:
                        Owner = name
                - derived class constructor: If you want to create a derived class, you need to add a default constructor:
                    
            - Events
            - Finalizers
            - Indexers
            - Operators
            - Nested Types
    - **Type ACCESSIBILITY:**
        - *Client code:* Meant to be accessed from outside the class or struct
        - By default, accessibility is set to private
        - Access modifiers:
            - public
            - protected
            - internal
            - protected internal
            - private
            - private protected
    - **Type INHERITANCE:**
        - To organize your classes and create class hierarchies:
            - We use it when we have a class with some functionality, and we need another class which is very similar but has some additional or slightly different behaviour (eg car -> electric car)
        - Classes (but not structs!) can "inherit"
        - Classes can inherit attributes (**properties**) and behaviour (**methods**) from other classes:
            - A class derived from a **Base class** will automatically get all the `public`, `protected` and `internal` members of the base class, **except its constructors and finalizers** (so `private` members are excluded!)
        - The class which inherits is called a *subclass*, *derived class*, or *child class* and the class from which we are inheriting is called the *superclass*, *base class* or *parent class* (in C# there can be only one base class!)
        - Abstract class: one or more of their methods have no implementation -> the derived class will provide the missing implementation
        - Sealed class: A class that doesn't allow inheriting
        - `virtual` method is a method in the *base class*, that the *derived class* can overwrite (you can only change the content, not the signature or the return type!):
            - If a *base class* has a virtual method, it means it will check first if the *derived class* we are pointing to or referencing has that method, and implement that instead. If it doesn't, it will use the definition in the *base class*
            - These are the methods in `Object` class, that we can consider overwriting, when creating a derived class:
                - `Equals`: By default, equlaity is checked by reference, but we can override this to check for its attributes
                - `GetHashCode`: used when the object is placed in a hash map like collection, for example the `Dictionary`
                - `ToString`
                - (`Finalize`)
        - The **Object** base class:
            - It's a special built-in class located in `System` namespace
            - It's the base class of any new class created, so these 2 are equivalent:
                    
                    public class Card 
                    {
                        //...
                    }

                    public class Card : Object      // The ":" means the class in inheriting from "Object" class (but it's unnecessary, as this is the default)
                    {
                        //...
                    }

    - **Type INTERFACE:**
        - An interface contains definitions for a group of related functionalities that a non-abstract class or a struct *must* implement
        - To implement from an interface means that the type implements *all the methods* defined in the interface

    - **Generic types:** 
        - Classes, structs, and records can be defined with one or more type parameters
        - When creating an instance from the class `List<T>` by passing it a parameter: `List<string>` or `List<int>`
    - **Static types:**
        - Classes (but not structs or records) can be declared as static
        - A static class can contain only static members and can't be instantiated with the new keyword
        - Classes, structs, and records can contain static members
    - **Nested types:**
        - Nested within another **type**
    - **Partial types:**
        - You can define part of a class, struct, or method in one code file and another part in a separate code file
    - **Anonymous tpyes:**
        - Anonymous types are defined by their named data members
        - In situations where it isn't convenient or necessary to create a named class you use anonymous types

    - **Object initializer:**
        - You can instantiate and initialize class or struct objects, and collections of objects, by assigning values to its properties
    - **Extension methods:**
        - You can "extend" a class without creating a derived class by creating a separate type.
        - That type contains methods that can be called as if they belonged to the original type.
    - **Implicitly Typed Local Variables:**
        - Within a class or struct method, you can use implicit typing to instruct the compiler to determine a variable's type at compile time
    
    - **RECORDS:**
        - You can add the record modifier to a `class` or a `struct` (`record class` or `record struct`)
        - Records are types with built-in behavior for value-based equality, with the following features:
            - Concise syntax for creating a reference type with immutable properties.
            - Value equality: Two variables of a record type are equal if they have the same type, and if, for every field, the values in both records are equal. 
              Classes use reference equality: two variables of a class type are equal if they refer to the same object.
            - Concise syntax for nondestructive mutation. A `with` expression lets you create a new record instance that is a copy of an existing instance but with specified property values changed.
            - Built-in formatting for display. The `ToString` method prints the record type name and the names and values of public properties.
            - Support for inheritance hierarchies in record classes. Record `classes` support inheritance. Record `structs` don't support inheritance.

- **TYPES - REFERENCE vs VALUE:**
    - The **reason** we can store types differently is that it helps to reduce the occurrance of runtime exceptions:
        - a **value type** can never be `null` -> the will never throw a `NullReferenceException` (one of the most common exceptions in OOP languages)

    - **REFERENCE types:**
        - These **don't hold data directly**, but hold a *reference* or *pointer* to a **memory location** on the **heap**, where the actual object is stored
        - All **class types** are reference types (eg the `string` and `object` class is a reference type, but also `Arrays` and `Strings`, althought the last one is special as it's immutable)
        - Declaring multiple variables that point to the same object makes it possible to modify that object through multiple variables, if it's **mutable**.<br>
          (if it's set to **immutable**, like strings, we can't modify them, all modifications will create a new object):

                int[] numbers1 = {1,2,3};       // "Array" is a mutable reference type, so it is possible to change its elements after it's been created
                int[] numbers2 = numbers1;      // numbers1 is a variable that contains a reference to an int[] object, which is what will be copied to numbers2 as well! (so they reference the same memory location)

                numbers2[0] = 0;
                numbers1[1] = 0;

                Console.WriteLine(String.Join(",", numbers1)); //Prints 0,0,3
                Console.WriteLine(String.Join(",", numbers2)); //Prints 0,0,3

                Console.ReadKey();
    
    - **VALUE types:**
        - These **hold their data directly** and are **stored on the stack**
        - All built-in numeric types (`int`, `double`, `decimal`) and `bool`, `char`, `byte`, `enum` and even `DateTime` are value types.
        - To create a new `value` type, we need to use the `struct` keyword istead of `class` (the object reference will behave as a value type)
        - If you assign a value type variable to another, the value itself will be copied, and they both live on separately:

                int number1 = 0;
                int number2 = number1;          // number1's value gets copied as the value of number2, but they will live independently

                number1++;

                Console.WriteLine(number1); //Prints 1
                Console.WriteLine(number2); //Prints 0

                Console.ReadKey();
    
    - **Method parameters:**
        - When passing parameters into methods, de default behaviour is **pass by value**:
            - For **reference types** -> the reference is passed (because the reference type's value is the reference itself) -> we can make modifications to them inside the method:

                    int[] numbers = { 1, 2 };

                    PrintNumbers(numbers);      // Prints 1, 2

                    ChangeToZero(numbers);
                    PrintNumbers(numbers);      // Prints 0, 0 -> the modification was successful!

                    private void ChangeToZero(int[] arr)
                    {
                        arr[0] = 0;
                        arr[1] = 0;
                    }

                    private void PrintNumbers(int[] arr)
                    {
                        Console.WriteLine(String.Join(", ", arr));
                    }

            - For **value types** -> the actual value is passed -> we can't use it the same way:

                    int counter = 0;
            
                    Increment(counter);
                    
                    Console.WriteLine(counter);     // Prints 0, so the modification was unsuccessful (because we were trying to modify the original value)
                    Console.ReadKey();
                    
                    private static void Increment(int num)
                    {
                        num += 1;
                    }

                    // So we can modify the code with the "ref" keyword:

                    int counter = 0;
                    
                    Increment(ref counter);         // ref also needs to be specified by the caller
                    
                    Console.WriteLine(counter);     // Prints 1
                    Console.ReadKey();

                    private static void Increment(ref int num)
                    {
                        num += 1;
                    }

                    // But a more realistic scenario is to just return a value from the local method (which will be a new integer):

                    int counter = 0;

                    counter = Increment(counter);   // We assign it a new value, not try to modify the original
                    
                    Console.WriteLine(counter);     // Prints 1
                    Console.ReadKey();

                    private static int Increment(int num)
                    {
                        return num + 1;             // The returned value will be a new integer
                    }
- **TYPES - BASIC types:**
    - **Built-in types (*=primitives*):**
        - Numbers:
            - `int` - range from -2,147,483,648 to 2,147,483,648 (because it's stored on 32bits, so 2^31-1, or 4,294,967,295)
            - `short` - a 16-bit signed number, so it's range is -32,768 to 32,767
            - `long` - a 64-bit number, so the range is -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
            - `float` - A single precision floating point number
            - `double` - A double-precision floating point number (Double-precision is a relative term that describes the numbers of binary digits used to store the value)
            - `decimal` number type has a larger range as `int`, but not as big as `double`. In return, they store a lot more precision. There is also a letter `m` at the end of the number
        - Text: (implemented with an iterator, so it is possible to iterate a string like you would do with a collection)
            - `char`
            - `string` 
        - `bool`
        - `byte`
    - **Framework types:**
        - `Array`:
            - a simple data structure in which you can store multiple variables of the same type
            - They represent a contiguous area in the memory, where the elements are placed next to each other
            - The size of the array (the number of elements it holds) needs to be specified at creation (different from JS!), so it's **not dynamic**!
            - The base class they inherit from is `System.Array`
            - Declaration example:
                    int[] array1 = { 4, 8, 15, 16, 23, 42};     // Create instantly
                    int[] array2 = new int[5];                  // Create placeholder by specifying number of elements (eg. 5) , and add them later
        - `List<T>`:
            - It's an indexable collection
            - Very similar to arrays, but it's **dynamic**, so in most cases it's prefered to use a list
            - `<T>` refers to the type of items it stores
        - `Console`:
            - Derived from the `System.Console` class
            - It's a `static` class
            - All the functionality is realted to console in and output (since we will be working with Console Applications, the main user interactions happens through the console)
        - `DateTime`:
            - Anything date related can be created with it
        - `Random`:
            - Generates random numbers
        - `Thread`:
            - A `thread` is a unit of execution (in this module we are only working in a singlethreaded environment) -> so we will only have 1 thread, the **main thread**
            - `Thread.Sleep` method can be used to defer (delay?) the execution of the current thread by 'x' milliseconds

## DATA TYPES and BUILDING BLOCKS OF CODE:
- **BASICS:**
    - Output to console:
            Console.WriteLine("string text");

    - Create a variable:
            var container = "this is the value of the container";
    
    - Create regions to separate functionalities and structurize the file:

                #region User Input
                // CODE GOES HERE
                #endregion

- **STRINGS:**
    - Create variable and use `string literal` to display it's value:
            string myName = "Gabor";                    // Using value type to create variable(!)
            string aFriend = "Dori";
            Console.WriteLine($"Hello, my name is {myName}");
            Console.WriteLine("Hello " + aFriend);

    - Using `length` property:
            string myName = "Gabor"
            Console.WriteLine($"{myName} consists of {myName.Length} characters");
    
    - Parsing strings (full description here: https://journey.study/v2/learn/materials/parsing-strings-csharp-1q2023):
        - convert one data type into another (eg. read a `string` input from the console and output an `int`)
        - Methods used:
            - `Console.ReadLine() ?? "";` - we use this to read the input from the console (the `??` operator is called the **null-coalescing operator**)
            - `Int32.Parse(input);` - then we used this line to convert (parse) it to an `int` type
            - `Console.ReadKey();` - it's used to wait for an input from the user (it avoids closing the application after completion of the task)
            - Using the `TryParse` method:
                    
                    private static bool ParseInput(string input, out int number)
                    {
                        return Int32.TryParse(input, out number);
                    }

                    // Code breakdown:
                    1. The TryParse method will try to perform the parse operation on the input data, and if it's not successful, it will return false
                    2. It won't throw any exceptions, but it will still give you information that the operation has failed (the program execution can continue)
                    3. If the parse operation is successful, the method will return true, and the parsed value will be assigned to the out parameter, in our case called number
                    4. The "out" modifier is quite similar to the "ref" modifier, in that it causes the parameter to be passed by reference. The "out" variable however does not have to be initialized, as in the case of "ref".
- **NUMBERS:**
    - Creating numbers:
            int number = 6;                                     // Integer division always results in an integer! (So it only returns the whole part of the result)

    - All types are implemented to support all:
        - **arithmetic** (+, -, *, /, %)
        - **comparison** (<, >, <=, >=)
        - **equality operators** (==, !=)

    - Min and Max values that they can represent (based on PC memory):
            int max = int.MaxValue;                     // 2147483647
            int min = int.MinValue;                     // -2147483647

            // OVERFLOW: We flip at the ends, so if we add 1 to the max, we get the first possible negative value
            // We need different types from int to express larger or different numbers

    - `float` and `double`
            float number = 4.5                                  // A single precision floating point number
            double number = 4.5                                 // A double-precision floating point number (Double-precision is a relative term that describes the numbers of binary digits used to store the value)

            // double third = 1.0 / 3.0;                        // 0.333333333333333 -> There is a limit to the decimals the computer can store

    - `decimal` number type has a larger range as `int`, but not as big as `double`. In return, they store a lot more precision:

            // decimal c = 1.0M;
            // decimal d = 3.0M;
            // Console.WriteLine(c / d);                        // 0.3333333333333333333333333333 -> The limit increased (also note the letter 'M' at the end, saying that it's a decimal! Otherwise it would consider it a "double")
    
    - `long` and `short` are also number types

- **ARRAYS, LISTS & COLLECTIONS:**
    - **Lists:**
        - Create a **list** in online browser environment (or add `using System.Collections.Generic` to imports):
                var names = new List<string> { "Juan", "Ana", "Felipe" };       // A "List" of "<string>"s
                foreach (var name in names)
                {
                    Console.WriteLine($"Hello {name.ToUpper()}!");
                }
        
        - Create a **list** in your own environment:
                List<string> names = ["Juan", "Ana", "Felipe"];
                foreach (var name in names)
                {
                    Console.WriteLine($"Hello {name.ToUpper()}!");
                }
    
    - **Enum:**
        - "Enumeration":
            - It's a **value type** that helps you define a group of named constants (*represent a fixed set of distinct values*)
            - Each constant in the enum representsan integral value (eg. `int`, `byte`, `long`) -> for readability these are raplaced with descriptive names
            - We use them when there is a set of options we can pick from, but these are not expandable (eg. card suits, days of the week, etc.)
            - By default, the underlying type of each element in the enum is `int`, and the first enumerator has the value `0`
        - Example:
                
                // Declare an enum:
                enum DayOfWeek
                {
                    Sunday,     // value = 0
                    Monday,     // value = 1
                    Tuesday,
                    Wednesday,
                    Thursday,
                    Friday,
                    Saturday    // value = 6
                }

                // Alternative declaration if we wnat any other type than "int":
                enum DayOfWeek : long
                {
                    Monday = 1,
                    ...
                }

                // Call it's values:
                DayOfWeek today = DayOfWeek.Wednesday;  // note the type here is the name of the enum!

                if (today == DayOfWeek.Wednesday)       // we use dot notation to express a value
                {
                    Console.WriteLine("It's Wednesday!");
                }

## CONDITIONALS / BRANCHES:
- Conditional `if` statemens:
        int a = 5;
        int b = 6;
        if (a + b > 10)
            {
            Console.WriteLine("The answer is greater than 10.");
            }
        else
            {
            Console.WriteLine("The answer is less or equal to 10.");
            }
        
        // we can combine conditions as in JS: if 
        if ((a + b + c > 10) && (a == b))
        if ((a + b + c > 10) || (a == b))
- Switch statements: (same as JS)
        switch (dayNum)                             // Condition to check in cases
        {
            case 0:                                 // Means if (dayNum == 0) is true
                dayName = "Sunday";
                break;                              // break is needed, otherwise the code would keep running
            case 1:
                dayName = "Monday";
                break;
            case 2:
                dayName = "Tuesday";
                break;
            ...
            case 6:
                dayName = "Saturday";
                break;
            default:                                // "else" case, if none of the above is true
                dayName = "Invalid Day Number!";
                break;
        }

## LOOPS:
- `while` loop:
        int counter = 0;
        while (counter < 10)
        {
            Console.WriteLine($"Hello World! The counter is {counter}");
            counter++;
        }
- `do while` loop (the condition is executed first, then checked):
        int counter = 0;
        do
        {
            Console.WriteLine($"Hello World! The counter is {counter}");
            counter++;
        } while (counter < 10);
- `for` loop:
        for (int counter = 0; counter < 10; counter++)
        {
            Console.WriteLine($"Hello World! The counter is {counter}");
        }
- `foreach`:
        foreach (var name in names)
        {
            Console.WriteLine($"Hello {name.ToUpper()}!");
        }

## METHODS:
- **Overview:**
    - In C# methods and functions are the same
    - They are the most basic **building blocks** of the code after the loops and conditionals
    - The main roles are:
        - Avoid code repetition by reusing code blocks
        - Make the code more readable for humans
- **Anatomy of a method:**
    - `private`, `static` and `void` are all additional keywords we use to describe the details of our method:
        - `private` means that the method can only be invoked from within the `Program` class.
        - `static`:
            - means the method can't be invoked through an object reference, only by the class name (eg. `Program.method()`)
            - if we want to call something from the `Main()` method, we need to make it `static` (because `Main` is also `static`, and it's the comiler's reqirement).
            - Since inside static methods we don't have an object reference of the enclosing type (in this case, Program), we can only call other static methods from it.
        - `void` refers to what it returns (it could also be `string` or `int`)
    - **method signature:** 
        - the method's name and the parameters together `MethodName(parameters)` -> this is a unique identifier of the method (name is with Capital letter! *PascalCase*)
        - `void` is not part of it, which is important because of **member/method overloading** 
- **Method/member overloading:**
    - it means creating multiple elements with the same name, which only differ in the numbers of parameters
    - the return type **MUST** be the same for all members/methods!
    - This is beneficial, because we can create simple or more complex functions, based on the requirements (so we don't need to call the difficult one in all cases):
            
            // For example, we can add a single string parameter, or an array of strings as a parameter:
            private static void PrintMessage(string message)
            {
                Console.WriteLine(message); 
            }

            private static void PrintMessage(string[] messages)
            {
                foreach (string message in messages)
                {
                    Console.WriteLine(message);
                }
            }

            // In this case, the type of the argument will determine which method will be invoked
- **Instance vs. Static methods:**
    - `static` methods are the ones that are called inside `Main()`, or we have to specifiy the Class name as well:
        - Access them through the **CLASS**
        - Some string methods work like this:

                String.Join(", ", messages);    // messages is an array of strings, on which we perform the Join method

    - `instance` methods on the other hand, **require** an object reference to be invoked:
        - Access them through the **OBJECT reference**
        - Most of the string methods for example are `instance` methods:
                
                message.ToUpper()               // message has to be a string on which we can invoke the method

- **Local method**
    - it's a method within another method - these are only accessible from the enclosing method
    - This is very important in the new Rider template, where we can only work within the `Main()` method, so **all methods will be local methods!**  

## CLASSES / PROCESS OF MODELING:
- Process of modeling (simplified summary):
    1. Analize object's attributes
    2. Filter these attributes to only include the relevant ones
    3. Decide which data types to use for the attributes
    4. Create Class

- Creating Classes:
    0. Create enum if there will be a property that is restricted to certain values:
            
            // In separate "Model" folder:
            namespace Codecool.PlayingCards.Model;

            public enum Suit {
                Diamonds,
                Clubs,
                Hearts,
                Spades,
            }

    1. Add properties:
        - **Auto properties** are properties that don't require the old way of creating a private field, then using another public field to get/set these values, instead this process is automatically generated in the background

                // The old way:
                private int _age;

                public int Age
                {
                    get { return _age; }
                    set { _age = value; }
                }

                // Properties with auto-properties and mutable values:
                public class Card {
                    public Suit Suit { get; set; }                  // use "init" instead of "set" if you want to make it immutable, or just remove "set"
                    public string Symbol { get; set; }
                }

    2. Add a constructor:

            public class Card {

                public Suit Suit { get; init; }                 // gets values from the enum we created for it
                public string Symbol { get; init; }             // value needs to be specified on initialization as string value
                public string Title => $"{Symbol} of {Suit}"    // This is a computed property with the arrow syntax, but we could add it to the constructor instead

                public Card(string symbol, Suit suit)
                {
                    Suit = suit;
                    Symbol = symbol;
                }
            }

    3. Change default inherited method definitions `Equals` and `GetHashCode`, then also `ToString`:
        - `Alt + Insert` hotkey, or right *click + generate* in `Card.cs` Class file, to add the following:
                
                protected bool Equals(Card other)
                {
                    return Suit == other.Suit && Symbol == other.Symbol;
                }

                public override bool Equals(object? obj)
                {
                    if (ReferenceEquals(null, obj)) return false;
                    if (ReferenceEquals(this, obj)) return true;
                    if (obj.GetType() != this.GetType()) return false;
                    return Equals((Card)obj);
                }

                public override int GetHashCode()
                {
                    return HashCode.Combine((int)Suit, Symbol);
                }
        
        - After overwriting, we should check for equality with the following method, not the `==` operator (this would only call `ReferenceEquals` methods again):

                Card card1 = new Card("Ace", Suit.Spades);
                Card card2 = new Card("Ace", Suit.Spades);

                Console.WriteLine(card1.Equals(card2)); // Prints True    
        
        - Update `ToString` as well:

                public override string ToString()
                {
                    return Title;
                }

                // So now instead of printing "PlayingCards.Card", it will print the Title attribute's value "Ace of Spades"
                Card card1 = new Card("Ace", Suit.Spades);

                Console.WriteLine(card1); // Prints Ace of Spades

    4. Create single object from Class in Program.cs file:

            Card card = new Card("Ace", Suit.Spades);

            // Use or call its attributes:
            Console.WriteLine(card.Title);

            // If it's mutable, we can overwrite its attributes after initializeation:
            card.Symbol = "King"
            card.Suit = Suit.Hearts;
    
    5. Generate the full deck:
        - In `Program.cs` file we create a new method called `GenerateFrenchDeck`:
                
                static Card[] GenerateFrenchDeck()
                {   
                    // Create initial data for deck:
                    Card[] deck = new Card[52];
                    int index = 0;

                    // Iterate through the suits:
                    foreach (var suit in Enum.GetValues<Suit>())
                    {
                        AddNumberedCards(deck, ref index, suit);        // Note "ref" keyword! This is to avoid passing paramters into methods "by value", which means a new memory storage is created for each method call 
                        AddCourtCards(deck, ref index, suit);           // ref keyword!
                    }

                    return deck;
                }

                // Generate numbered cards:
                static void AddNumberedCards(Card[] deck, ref int index, Suit suit)     // ref keyword!
                {
                    for (int i = 2; i <= 10; i++)
                    {
                        Card card = new Card(i.ToString(), suit);
                        deck[index] = card;
                        index++;
                    }
                }

                // Generate court cards:
                static void AddCourtCards(Card[] deck, ref int index, Suit suit)        // ref keyword!
                {
                    string[] courtSymbols = { "Jack", "Queen", "King", "Ace" };

                    foreach (var courtSymbol in courtSymbols)
                    {
                        Card card = new Card(courtSymbol, suit);
                        deck[index] = card;
                        index++;
                    }
                }

                // Then we can add these lines to the `Main` method to actually generate the cards:
                Card[] deck = GenerateFrenchDeck();

                for (int i = 0; i < deck.Length; i++)
                {
                    Console.WriteLine($"{i + 1} - {deck[i]}");
                }

                Console.ReadKey();

        - The same code using `List` (to avoid dealing with `index` and `ref`):

                static List<Card> GenerateFrenchDeck()
                {
                    // Create initial data for deck:
                    List<Card> deck = new List<Card>();

                    // Iterate through the suits:
                    foreach (var suit in Enum.GetValues<Suit>())
                    {
                        AddNumberedCards(deck, suit);
                        AddCourtCards(deck, suit);
                    }

                    return deck;
                }

                // Generate numbered cards:
                static void AddNumberedCards(List<Card> deck, Suit suit)
                {
                    for (int i = 2; i <= 10; i++)
                    {
                        Card card = new Card(i.ToString(), suit);
                        deck.Add(card);
                    }
                }

                // Generate court cards:
                static void AddCourtCards(List<Card> deck, Suit suit)
                {
                    string[] courtSymbols = { "Jack", "Queen", "King", "Ace" };

                    foreach (var courtSymbol in courtSymbols)
                    {
                        Card card = new Card(courtSymbol, suit);
                        deck.Add(card);
                    }
                }

                // Then call it like this:
                List<Card> deck = GenerateFrenchDeck();

                for (int i = 0; i < deck.Count; i++)
                {
                    Console.WriteLine($"{i + 1} - {deck[i]}");
                }                
    
    6. Decide between **simplicity** or **robustness**:
        - **Robustness**:
            - using inheritance (or enums) by creating sub-classes and a base-class
            - better scalability
            - worse performance
            - more difficult to maintain
            - leaves less space fo incorrect use of class
        - **Simplicity**: (sample https://journey.study/v2/learn/materials/cards-german-deck-csharp-1q2023)
            - avoid inheritance, and create multiple independent classes instead of a base-class and subclasses 
            - worse for scalability
            - better performance
            - easier to maintain
            - might lead to incorrect use of class
    
    7. Add functionality (behaviour methods)

## ADDITIONAL SUMMARY FROM https://www.youtube.com/watch?v=GhQdlIFylQ8&ab_channel=freeCodeCamp.org
- 


# SPECIFIC METHODS:
### **Console methods:**
- Display information:
        Console.WriteLine();                        // Write something and jump to next line
        Console.WriteLine();                        // Write something and stay in the line

        Console.ReadLine();                         // Wait for input followed by the ENTER key (It stores values as strings! Conversion is needed for numbers)

- Get information (eg user input):

        Console.Write("Enter your name: ");
        string name = Console.ReadLine();
        Console.WriteLine($"Hello {name}!");

### **String methods:**
- Trim:
        greeting.Trim();
        greeting.TrimStart();
        greeting.TrimEnd();

- Replace:
        string sayhello = "Hello World!"
        sayHello.Replace("Hello", "Greetings")      // "Hello World!" -> "Greetings World!" 
        sayHello.ToUpper()                          // "Hello World!" -> "HELLO WORLD!" 
        sayHello.ToLower()                          // "Hello World!" -> "hello world!"

- Search:
        string songLyrics = "You say goodbye, and I say hello";
        songLyrics.Contains("goodbye")              // True
        songLyrics.Contains("greetings")            // False

        songLyrics.StarsWith("You")                 // True
        songLyrics.EndsWith("Me")                   // False

- Convert:
        int num = Convert.ToInt32("45");            // Convert an stinrg into an integer 

### **Numbers methods:**
- Basic Math operations: + - / * %
- Math class methods:
        Math.PI
        int.MaxValue;
        int.MinValue;

### **Array-List-Collection methods:**
- Indexing:
        names[0] -> refers to the first element
        names[names.Count - 1] -> refers to the last element
- Add/remove elements:
        names.Add("Bill");
        names.Remove("Ana");
- Length of a list:
        names.Count
- Searching:
        var index = names.IndexOf("Felipe");        // Returns -1 if it doesn't find something

        // So it's a good practice to add an if statement, to do the action only if the item is found:
        if (index != -1)
        {
            Console.WriteLine($"The name {names[index]} is at index {index}");
        }
- Sort (modifies items in place, so modifies the original list):
        names.Sort();                               // Recognizes the data type, and uses Quicksort/Introsort to sort data (so numbers in an ascending order, strings alphabetically)
        foreach (var name in names)
        {
            Console.WriteLine($"Hello {name.ToUpper()}!");
        }
    
